/**
 * worker must be started as a child process or a web worker.
 * It listens for RPC messages from the parent process.
 */

// source of inspiration: https://github.com/sindresorhus/require-fool-webpack
const requireFoolWebpack = eval(
  'typeof require !== \'undefined\''
    + ' ? require'
    + ' : function (module) { throw new Error(\'Module " + module + " not found.\') }',
);

/**
 * Special message sent by parent which causes the worker to terminate itself.
 * Not a "message object"; this string is the entire message.
 */
const TERMINATE_METHOD_ID = '__workerpool-terminate__';

// var nodeOSPlatform = require('./environment').nodeOSPlatform;

// create a worker API for sending and receiving messages which works both on
// node.js and in the browser
const worker = {
  exit() {},
};
if (typeof self !== 'undefined' && typeof postMessage === 'function' && typeof addEventListener === 'function') {
  // worker in the browser
  worker.on = function (event, callback) {
    addEventListener(event, (message) => {
      callback(message.data);
    });
  };
  worker.send = function (message) {
    postMessage(message);
  };
} else if (typeof process !== 'undefined') {
  // node.js

  let WorkerThreads;
  try {
    WorkerThreads = requireFoolWebpack('worker_threads');
  } catch (error) {
    if (typeof error === 'object' && error !== null && error.code === 'MODULE_NOT_FOUND') {
      // no worker_threads, fallback to sub-process based workers
    } else {
      throw error;
    }
  }

  if (WorkerThreads
    /* if there is a parentPort, we are in a WorkerThread */
    && WorkerThreads.parentPort !== null) {
    const { parentPort } = WorkerThreads;
    worker.send = parentPort.postMessage.bind(parentPort);
    worker.on = parentPort.on.bind(parentPort);
  } else {
    worker.on = process.on.bind(process);
    worker.send = process.send.bind(process);
    // register disconnect handler only for subprocess worker to exit when parent is killed unexpectedly
    worker.on('disconnect', () => {
      process.exit(1);
    });
    worker.exit = process.exit.bind(process);
  }
} else {
  throw new Error('Script must be executed as a worker');
}

function convertError(error) {
  return Object.getOwnPropertyNames(error).reduce((product, name) => Object.defineProperty(product, name, {
    value: error[name],
    enumerable: true,
  }), {});
}

/**
 * Test whether a value is a Promise via duck typing.
 * @param {*} value
 * @returns {boolean} Returns true when given value is an object
 *                    having functions `then` and `catch`.
 */
function isPromise(value) {
  return value && (typeof value.then === 'function') && (typeof value.catch === 'function');
}

// functions available externally
worker.methods = {};

/**
 * Execute a function with provided arguments
 * @param {String} fn     Stringified function
 * @param {Array} [args]  Function arguments
 * @returns {*}
 */
worker.methods.run = function run(fn, args) {
  const f = new Function(`return (${fn}).apply(null, arguments);`);
  return f.apply(f, args);
};

/**
 * Get a list with methods available on this worker
 * @return {String[]} methods
 */
worker.methods.methods = function methods() {
  return Object.keys(worker.methods);
};

let currentRequestId = null;

worker.on('message', (request) => {
  if (request === TERMINATE_METHOD_ID) {
    return worker.exit(0);
  }
  try {
    const method = worker.methods[request.method];

    if (method) {
      currentRequestId = request.id;

      // execute the function
      const result = method.apply(method, request.params);

      if (isPromise(result)) {
        // promise returned, resolve this and then return
        result
          .then((result) => {
            worker.send({
              id: request.id,
              result,
              error: null,
            });
            currentRequestId = null;
          })
          .catch((err) => {
            worker.send({
              id: request.id,
              result: null,
              error: convertError(err),
            });
            currentRequestId = null;
          });
      } else {
        // immediate result
        worker.send({
          id: request.id,
          result,
          error: null,
        });

        currentRequestId = null;
      }
    } else {
      throw new Error(`Unknown method "${request.method}"`);
    }
  } catch (err) {
    worker.send({
      id: request.id,
      result: null,
      error: convertError(err),
    });
  }
});

/**
 * Register methods to the worker
 * @param {Object} methods
 */
worker.register = function (methods) {
  if (methods) {
    for (const name in methods) {
      if (methods.hasOwnProperty(name)) {
        worker.methods[name] = methods[name];
      }
    }
  }

  worker.send('ready');
};

worker.emit = function (payload) {
  if (currentRequestId) {
    worker.send({
      id: currentRequestId,
      isEvent: true,
      payload,
    });
  }
};

if (typeof exports !== 'undefined') {
  exports.add = worker.register;
  exports.emit = worker.emit;
}
