/* globals suite test */

const assert = require('assert');
const path = require('path');
const { exec } = require('child_process');
const pkg = require('../package.json');
const flat = require('../index');

const { flatten } = flat;
const { unflatten } = flat;

const primitives = {
  String: 'good morning',
  Number: 1234.99,
  Boolean: true,
  Date: new Date(),
  null: null,
  undefined,
};

suite('Flatten Primitives', () => {
  Object.keys(primitives).forEach((key) => {
    const value = primitives[key];

    test(key, () => {
      assert.deepStrictEqual(flatten({
        hello: {
          world: value,
        },
      }), {
        'hello.world': value,
      });
    });
  });
});

suite('Unflatten Primitives', () => {
  Object.keys(primitives).forEach((key) => {
    const value = primitives[key];

    test(key, () => {
      assert.deepStrictEqual(unflatten({
        'hello.world': value,
      }), {
        hello: {
          world: value,
        },
      });
    });
  });
});

suite('Flatten', () => {
  test('nested once', () => {
    assert.deepStrictEqual(flatten({
      hello: {
        world: 'good morning',
      },
    }), {
      'hello.world': 'good morning',
    });
  });

  test('nested twice', () => {
    assert.deepStrictEqual(flatten({
      hello: {
        world: {
          again: 'good morning',
        },
      },
    }), {
      'hello.world.again': 'good morning',
    });
  });

  test('multiple Keys', () => {
    assert.deepStrictEqual(flatten({
      hello: {
        lorem: {
          ipsum: 'again',
          dolor: 'sit',
        },
      },
      world: {
        lorem: {
          ipsum: 'again',
          dolor: 'sit',
        },
      },
    }), {
      'hello.lorem.ipsum': 'again',
      'hello.lorem.dolor': 'sit',
      'world.lorem.ipsum': 'again',
      'world.lorem.dolor': 'sit',
    });
  });

  test('custom Delimiter', () => {
    assert.deepStrictEqual(flatten({
      hello: {
        world: {
          again: 'good morning',
        },
      },
    }, {
      delimiter: ':',
    }), {
      'hello:world:again': 'good morning',
    });
  });

  test('empty Objects', () => {
    assert.deepStrictEqual(flatten({
      hello: {
        empty: {
          nested: {},
        },
      },
    }), {
      'hello.empty.nested': {},
    });
  });

  if (typeof Buffer !== 'undefined') {
    test('buffer', () => {
      assert.deepStrictEqual(flatten({
        hello: {
          empty: {
            nested: Buffer.from('test'),
          },
        },
      }), {
        'hello.empty.nested': Buffer.from('test'),
      });
    });
  }

  if (typeof Uint8Array !== 'undefined') {
    test('typed arrays', () => {
      assert.deepStrictEqual(flatten({
        hello: {
          empty: {
            nested: new Uint8Array([1, 2, 3, 4]),
          },
        },
      }), {
        'hello.empty.nested': new Uint8Array([1, 2, 3, 4]),
      });
    });
  }

  test('custom Depth', () => {
    assert.deepStrictEqual(flatten({
      hello: {
        world: {
          again: 'good morning',
        },
      },
      lorem: {
        ipsum: {
          dolor: 'good evening',
        },
      },
    }, {
      maxDepth: 2,
    }), {
      'hello.world': {
        again: 'good morning',
      },
      'lorem.ipsum': {
        dolor: 'good evening',
      },
    });
  });

  test('transformed Keys', () => {
    assert.deepStrictEqual(flatten({
      hello: {
        world: {
          again: 'good morning',
        },
      },
      lorem: {
        ipsum: {
          dolor: 'good evening',
        },
      },
    }, {
      transformKey(key) {
        return `__${key}__`;
      },
    }), {
      '__hello__.__world__.__again__': 'good morning',
      '__lorem__.__ipsum__.__dolor__': 'good evening',
    });
  });

  test('should keep number in the left when object', () => {
    assert.deepStrictEqual(flatten({
      hello: {
        '0200': 'world',
        '0500': 'darkness my old friend',
      },
    }), {
      'hello.0200': 'world',
      'hello.0500': 'darkness my old friend',
    });
  });
});

suite('Unflatten', () => {
  test('nested once', () => {
    assert.deepStrictEqual({
      hello: {
        world: 'good morning',
      },
    }, unflatten({
      'hello.world': 'good morning',
    }));
  });

  test('nested twice', () => {
    assert.deepStrictEqual({
      hello: {
        world: {
          again: 'good morning',
        },
      },
    }, unflatten({
      'hello.world.again': 'good morning',
    }));
  });

  test('multiple Keys', () => {
    assert.deepStrictEqual({
      hello: {
        lorem: {
          ipsum: 'again',
          dolor: 'sit',
        },
      },
      world: {
        greet: 'hello',
        lorem: {
          ipsum: 'again',
          dolor: 'sit',
        },
      },
    }, unflatten({
      'hello.lorem.ipsum': 'again',
      'hello.lorem.dolor': 'sit',
      'world.lorem.ipsum': 'again',
      'world.lorem.dolor': 'sit',
      world: { greet: 'hello' },
    }));
  });

  test('nested objects do not clobber each other when a.b inserted before a', () => {
    const x = {};
    x['foo.bar'] = { t: 123 };
    x.foo = { p: 333 };
    assert.deepStrictEqual(unflatten(x), {
      foo: {
        bar: {
          t: 123,
        },
        p: 333,
      },
    });
  });

  test('custom Delimiter', () => {
    assert.deepStrictEqual({
      hello: {
        world: {
          again: 'good morning',
        },
      },
    }, unflatten({
      'hello world again': 'good morning',
    }, {
      delimiter: ' ',
    }));
  });

  test('overwrite', () => {
    assert.deepStrictEqual({
      travis: {
        build: {
          dir: '/home/travis/build/kvz/environmental',
        },
      },
    }, unflatten({
      travis: 'true',
      travis_build_dir: '/home/travis/build/kvz/environmental',
    }, {
      delimiter: '_',
      overwrite: true,
    }));
  });

  test('transformed Keys', () => {
    assert.deepStrictEqual(unflatten({
      '__hello__.__world__.__again__': 'good morning',
      '__lorem__.__ipsum__.__dolor__': 'good evening',
    }, {
      transformKey(key) {
        return key.substring(2, key.length - 2);
      },
    }), {
      hello: {
        world: {
          again: 'good morning',
        },
      },
      lorem: {
        ipsum: {
          dolor: 'good evening',
        },
      },
    });
  });

  test('messy', () => {
    assert.deepStrictEqual({
      hello: { world: 'again' },
      lorem: { ipsum: 'another' },
      good: {
        morning: {
          hash: {
            key: {
              nested: {
                deep: {
                  and: {
                    even: {
                      deeper: { still: 'hello' },
                    },
                  },
                },
              },
            },
          },
          again: { testing: { this: 'out' } },
        },
      },
    }, unflatten({
      'hello.world': 'again',
      'lorem.ipsum': 'another',
      'good.morning': {
        'hash.key': {
          'nested.deep': {
            'and.even.deeper.still': 'hello',
          },
        },
      },
      'good.morning.again': {
        'testing.this': 'out',
      },
    }));
  });

  suite('Overwrite + non-object values in key positions', () => {
    test('non-object keys + overwrite should be overwritten', () => {
      assert.deepStrictEqual(flat.unflatten({ a: null, 'a.b': 'c' }, { overwrite: true }), { a: { b: 'c' } });
      assert.deepStrictEqual(flat.unflatten({ a: 0, 'a.b': 'c' }, { overwrite: true }), { a: { b: 'c' } });
      assert.deepStrictEqual(flat.unflatten({ a: 1, 'a.b': 'c' }, { overwrite: true }), { a: { b: 'c' } });
      assert.deepStrictEqual(flat.unflatten({ a: '', 'a.b': 'c' }, { overwrite: true }), { a: { b: 'c' } });
    });

    test('overwrite value should not affect undefined keys', () => {
      assert.deepStrictEqual(flat.unflatten({ a: undefined, 'a.b': 'c' }, { overwrite: true }), { a: { b: 'c' } });
      assert.deepStrictEqual(flat.unflatten({ a: undefined, 'a.b': 'c' }, { overwrite: false }), { a: { b: 'c' } });
    });

    test('if no overwrite, should ignore nested values under non-object key', () => {
      assert.deepStrictEqual(flat.unflatten({ a: null, 'a.b': 'c' }), { a: null });
      assert.deepStrictEqual(flat.unflatten({ a: 0, 'a.b': 'c' }), { a: 0 });
      assert.deepStrictEqual(flat.unflatten({ a: 1, 'a.b': 'c' }), { a: 1 });
      assert.deepStrictEqual(flat.unflatten({ a: '', 'a.b': 'c' }), { a: '' });
    });
  });

  suite('.safe', () => {
    test('should protect arrays when true', () => {
      assert.deepStrictEqual(flatten({
        hello: [
          { world: { again: 'foo' } },
          { lorem: 'ipsum' },
        ],
        another: {
          nested: [{ array: { too: 'deep' } }],
        },
        lorem: {
          ipsum: 'whoop',
        },
      }, {
        safe: true,
      }), {
        hello: [
          { world: { again: 'foo' } },
          { lorem: 'ipsum' },
        ],
        'lorem.ipsum': 'whoop',
        'another.nested': [{ array: { too: 'deep' } }],
      });
    });

    test('should not protect arrays when false', () => {
      assert.deepStrictEqual(flatten({
        hello: [
          { world: { again: 'foo' } },
          { lorem: 'ipsum' },
        ],
      }, {
        safe: false,
      }), {
        'hello.0.world.again': 'foo',
        'hello.1.lorem': 'ipsum',
      });
    });

    test('empty objects should not be removed', () => {
      assert.deepStrictEqual(unflatten({
        foo: [],
        bar: {},
      }), { foo: [], bar: {} });
    });
  });

  suite('.object', () => {
    test('should create object instead of array when true', () => {
      const unflattened = unflatten({
        'hello.you.0': 'ipsum',
        'hello.you.1': 'lorem',
        'hello.other.world': 'foo',
      }, {
        object: true,
      });
      assert.deepStrictEqual({
        hello: {
          you: {
            0: 'ipsum',
            1: 'lorem',
          },
          other: { world: 'foo' },
        },
      }, unflattened);
      assert(!Array.isArray(unflattened.hello.you));
    });

    test('should create object instead of array when nested', () => {
      const unflattened = unflatten({
        hello: {
          'you.0': 'ipsum',
          'you.1': 'lorem',
          'other.world': 'foo',
        },
      }, {
        object: true,
      });
      assert.deepStrictEqual({
        hello: {
          you: {
            0: 'ipsum',
            1: 'lorem',
          },
          other: { world: 'foo' },
        },
      }, unflattened);
      assert(!Array.isArray(unflattened.hello.you));
    });

    test('should keep the zero in the left when object is true', () => {
      const unflattened = unflatten({
        'hello.0200': 'world',
        'hello.0500': 'darkness my old friend',
      }, {
        object: true,
      });

      assert.deepStrictEqual({
        hello: {
          '0200': 'world',
          '0500': 'darkness my old friend',
        },
      }, unflattened);
    });

    test('should not create object when false', () => {
      const unflattened = unflatten({
        'hello.you.0': 'ipsum',
        'hello.you.1': 'lorem',
        'hello.other.world': 'foo',
      }, {
        object: false,
      });
      assert.deepStrictEqual({
        hello: {
          you: ['ipsum', 'lorem'],
          other: { world: 'foo' },
        },
      }, unflattened);
      assert(Array.isArray(unflattened.hello.you));
    });
  });

  if (typeof Buffer !== 'undefined') {
    test('buffer', () => {
      assert.deepStrictEqual(unflatten({
        'hello.empty.nested': Buffer.from('test'),
      }), {
        hello: {
          empty: {
            nested: Buffer.from('test'),
          },
        },
      });
    });
  }

  if (typeof Uint8Array !== 'undefined') {
    test('typed arrays', () => {
      assert.deepStrictEqual(unflatten({
        'hello.empty.nested': new Uint8Array([1, 2, 3, 4]),
      }), {
        hello: {
          empty: {
            nested: new Uint8Array([1, 2, 3, 4]),
          },
        },
      });
    });
  }

  test('should not pollute prototype', () => {
    unflatten({
      '__proto__.polluted': true,
    });
    unflatten({
      'prefix.__proto__.polluted': true,
    });
    unflatten({
      'prefix.0.__proto__.polluted': true,
    });

    assert.notStrictEqual({}.polluted, true);
  });
});

suite('Arrays', () => {
  test('should be able to flatten arrays properly', () => {
    assert.deepStrictEqual({
      'a.0': 'foo',
      'a.1': 'bar',
    }, flatten({
      a: ['foo', 'bar'],
    }));
  });

  test('should be able to revert and reverse array serialization via unflatten', () => {
    assert.deepStrictEqual({
      a: ['foo', 'bar'],
    }, unflatten({
      'a.0': 'foo',
      'a.1': 'bar',
    }));
  });

  test('array typed objects should be restored by unflatten', () => {
    assert.strictEqual(
      Object.prototype.toString.call(['foo', 'bar']),
      Object.prototype.toString.call(unflatten({
        'a.0': 'foo',
        'a.1': 'bar',
      }).a),
    );
  });

  test('do not include keys with numbers inside them', () => {
    assert.deepStrictEqual(unflatten({
      '1key.2_key': 'ok',
    }), {
      '1key': {
        '2_key': 'ok',
      },
    });
  });
});

suite('Order of Keys', () => {
  test('order of keys should not be changed after round trip flatten/unflatten', () => {
    const obj = {
      b: 1,
      abc: {
        c: [{
          d: 1,
          bca: 1,
          a: 1,
        }],
      },
      a: 1,
    };
    const result = unflatten(
      flatten(obj),
    );

    assert.deepStrictEqual(Object.keys(obj), Object.keys(result));
    assert.deepStrictEqual(Object.keys(obj.abc), Object.keys(result.abc));
    assert.deepStrictEqual(Object.keys(obj.abc.c[0]), Object.keys(result.abc.c[0]));
  });
});

suite('CLI', () => {
  test('can take filename', () => new Promise((done) => {
    const cli = path.resolve(__dirname, '..', pkg.bin);
    const pkgJSON = path.resolve(__dirname, '..', 'package.json');
    exec(`${cli} ${pkgJSON}`, (err, stdout, stderr) => {
      assert.ifError(err);
      assert.strictEqual(stdout.trim(), JSON.stringify(flatten(pkg), null, 2));
      done();
    });
  }));

  test('exits with usage if no file', () => new Promise((done) => {
    const cli = path.resolve(__dirname, '..', pkg.bin);
    const pkgJSON = path.resolve(__dirname, '..', 'package.json');
    exec(`${cli} ${pkgJSON}`, (err, stdout, stderr) => {
      assert.ifError(err);
      assert.strictEqual(stdout.trim(), JSON.stringify(flatten(pkg), null, 2));
      done();
    });
  }));

  test('can take piped file', () => new Promise((done) => {
    const cli = path.resolve(__dirname, '..', pkg.bin);
    const pkgJSON = path.resolve(__dirname, '..', 'package.json');
    exec(`cat ${pkgJSON} | ${cli}`, (err, stdout, stderr) => {
      assert.ifError(err);
      assert.strictEqual(stdout.trim(), JSON.stringify(flatten(pkg), null, 2));
      done();
    });
  }));
});
