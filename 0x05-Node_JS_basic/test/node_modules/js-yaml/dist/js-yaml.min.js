/*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT */
!(function (e, t) { typeof exports === 'object' && typeof module !== 'undefined' ? t(exports) : typeof define === 'function' && define.amd ? define(['exports'], t) : t((e = typeof globalThis !== 'undefined' ? globalThis : e || self).jsyaml = {}); }(this, ((e) => {
  function t(e) { return e == null; } const n = {
    isNothing: t, isObject(e) { return typeof e === 'object' && e !== null; }, toArray(e) { return Array.isArray(e) ? e : t(e) ? [] : [e]; }, repeat(e, t) { let n; let i = ''; for (n = 0; n < t; n += 1)i += e; return i; }, isNegativeZero(e) { return e === 0 && Number.NEGATIVE_INFINITY === 1 / e; }, extend(e, t) { let n; let i; let r; let o; if (t) for (n = 0, i = (o = Object.keys(t)).length; n < i; n += 1)e[r = o[n]] = t[r]; return e; },
  }; function i(e, t) { let n = ''; const i = e.reason || '(unknown reason)'; return e.mark ? (e.mark.name && (n += `in "${e.mark.name}" `), n += `(${e.mark.line + 1}:${e.mark.column + 1})`, !t && e.mark.snippet && (n += `\n\n${e.mark.snippet}`), `${i} ${n}`) : i; } function r(e, t) { Error.call(this), this.name = 'YAMLException', this.reason = e, this.mark = t, this.message = i(this, !1), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = (new Error()).stack || ''; }r.prototype = Object.create(Error.prototype), r.prototype.constructor = r, r.prototype.toString = function (e) { return `${this.name}: ${i(this, e)}`; }; const o = r; function a(e, t, n, i, r) { let o = ''; let a = ''; const l = Math.floor(r / 2) - 1; return i - t > l && (t = i - l + (o = ' ... ').length), n - i > l && (n = i + l - (a = ' ...').length), { str: o + e.slice(t, n).replace(/\t/g, 'â†’') + a, pos: i - t + o.length }; } function l(e, t) { return n.repeat(' ', t - e.length) + e; } const c = function (e, t) { if (t = Object.create(t || null), !e.buffer) return null; t.maxLength || (t.maxLength = 79), typeof t.indent !== 'number' && (t.indent = 1), typeof t.linesBefore !== 'number' && (t.linesBefore = 3), typeof t.linesAfter !== 'number' && (t.linesAfter = 2); for (var i, r = /\r?\n|\r|\0/g, o = [0], c = [], s = -1; i = r.exec(e.buffer);)c.push(i.index), o.push(i.index + i[0].length), e.position <= i.index && s < 0 && (s = o.length - 2); s < 0 && (s = o.length - 1); let u; let p; let f = ''; const d = Math.min(e.line + t.linesAfter, c.length).toString().length; const h = t.maxLength - (t.indent + d + 3); for (u = 1; u <= t.linesBefore && !(s - u < 0); u++)p = a(e.buffer, o[s - u], c[s - u], e.position - (o[s] - o[s - u]), h), f = `${n.repeat(' ', t.indent) + l((e.line - u + 1).toString(), d)} | ${p.str}\n${f}`; for (p = a(e.buffer, o[s], c[s], e.position, h), f += `${n.repeat(' ', t.indent) + l((e.line + 1).toString(), d)} | ${p.str}\n`, f += `${n.repeat('-', t.indent + d + 3 + p.pos)}^\n`, u = 1; u <= t.linesAfter && !(s + u >= c.length); u++)p = a(e.buffer, o[s + u], c[s + u], e.position - (o[s] - o[s + u]), h), f += `${n.repeat(' ', t.indent) + l((e.line + u + 1).toString(), d)} | ${p.str}\n`; return f.replace(/\n$/, ''); }; const s = ['kind', 'multi', 'resolve', 'construct', 'instanceOf', 'predicate', 'represent', 'representName', 'defaultStyle', 'styleAliases']; const u = ['scalar', 'sequence', 'mapping']; const p = function (e, t) { if (t = t || {}, Object.keys(t).forEach(((t) => { if (s.indexOf(t) === -1) throw new o(`Unknown option "${t}" is met in definition of "${e}" YAML type.`); })), this.options = t, this.tag = e, this.kind = t.kind || null, this.resolve = t.resolve || function () { return !0; }, this.construct = t.construct || function (e) { return e; }, this.instanceOf = t.instanceOf || null, this.predicate = t.predicate || null, this.represent = t.represent || null, this.representName = t.representName || null, this.defaultStyle = t.defaultStyle || null, this.multi = t.multi || !1, this.styleAliases = (function (e) { const t = {}; return e !== null && Object.keys(e).forEach(((n) => { e[n].forEach(((e) => { t[String(e)] = n; })); })), t; }(t.styleAliases || null)), u.indexOf(this.kind) === -1) throw new o(`Unknown kind "${this.kind}" is specified for "${e}" YAML type.`); }; function f(e, t) { const n = []; return e[t].forEach(((e) => { let t = n.length; n.forEach(((n, i) => { n.tag === e.tag && n.kind === e.kind && n.multi === e.multi && (t = i); })), n[t] = e; })), n; } function d(e) { return this.extend(e); }d.prototype.extend = function (e) {
    let t = []; let n = []; if (e instanceof p)n.push(e); else if (Array.isArray(e))n = n.concat(e); else { if (!e || !Array.isArray(e.implicit) && !Array.isArray(e.explicit)) throw new o('Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })'); e.implicit && (t = t.concat(e.implicit)), e.explicit && (n = n.concat(e.explicit)); }t.forEach(((e) => { if (!(e instanceof p)) throw new o('Specified list of YAML types (or a single Type object) contains a non-Type object.'); if (e.loadKind && e.loadKind !== 'scalar') throw new o('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.'); if (e.multi) throw new o('There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.'); })), n.forEach(((e) => { if (!(e instanceof p)) throw new o('Specified list of YAML types (or a single Type object) contains a non-Type object.'); })); const i = Object.create(d.prototype); return i.implicit = (this.implicit || []).concat(t), i.explicit = (this.explicit || []).concat(n), i.compiledImplicit = f(i, 'implicit'), i.compiledExplicit = f(i, 'explicit'), i.compiledTypeMap = (function () {
      let e; let t; const n = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {},
        multi: {
          scalar: [], sequence: [], mapping: [], fallback: [],
        },
      }; function i(e) { e.multi ? (n.multi[e.kind].push(e), n.multi.fallback.push(e)) : n[e.kind][e.tag] = n.fallback[e.tag] = e; } for (e = 0, t = arguments.length; e < t; e += 1)arguments[e].forEach(i); return n;
    }(i.compiledImplicit, i.compiledExplicit)), i;
  }; const h = d; const g = new p('tag:yaml.org,2002:str', { kind: 'scalar', construct(e) { return e !== null ? e : ''; } }); const m = new p('tag:yaml.org,2002:seq', { kind: 'sequence', construct(e) { return e !== null ? e : []; } }); const y = new p('tag:yaml.org,2002:map', { kind: 'mapping', construct(e) { return e !== null ? e : {}; } }); const b = new h({ explicit: [g, m, y] }); const A = new p('tag:yaml.org,2002:null', {
    kind: 'scalar',
    resolve(e) { if (e === null) return !0; const t = e.length; return t === 1 && e === '~' || t === 4 && (e === 'null' || e === 'Null' || e === 'NULL'); },
    construct() { return null; },
    predicate(e) { return e === null; },
    represent: {
      canonical() { return '~'; }, lowercase() { return 'null'; }, uppercase() { return 'NULL'; }, camelcase() { return 'Null'; }, empty() { return ''; },
    },
    defaultStyle: 'lowercase',
  }); const v = new p('tag:yaml.org,2002:bool', {
    kind: 'scalar', resolve(e) { if (e === null) return !1; const t = e.length; return t === 4 && (e === 'true' || e === 'True' || e === 'TRUE') || t === 5 && (e === 'false' || e === 'False' || e === 'FALSE'); }, construct(e) { return e === 'true' || e === 'True' || e === 'TRUE'; }, predicate(e) { return Object.prototype.toString.call(e) === '[object Boolean]'; }, represent: { lowercase(e) { return e ? 'true' : 'false'; }, uppercase(e) { return e ? 'TRUE' : 'FALSE'; }, camelcase(e) { return e ? 'True' : 'False'; } }, defaultStyle: 'lowercase',
  }); function w(e) { return e >= 48 && e <= 55; } function k(e) { return e >= 48 && e <= 57; } const C = new p('tag:yaml.org,2002:int', {
    kind: 'scalar',
    resolve(e) { if (e === null) return !1; let t; let n; const i = e.length; let r = 0; let o = !1; if (!i) return !1; if ((t = e[r]) !== '-' && t !== '+' || (t = e[++r]), t === '0') { if (r + 1 === i) return !0; if ((t = e[++r]) === 'b') { for (r++; r < i; r++) if ((t = e[r]) !== '_') { if (t !== '0' && t !== '1') return !1; o = !0; } return o && t !== '_'; } if (t === 'x') { for (r++; r < i; r++) if ((t = e[r]) !== '_') { if (!((n = e.charCodeAt(r)) >= 48 && n <= 57 || n >= 65 && n <= 70 || n >= 97 && n <= 102)) return !1; o = !0; } return o && t !== '_'; } if (t === 'o') { for (r++; r < i; r++) if ((t = e[r]) !== '_') { if (!w(e.charCodeAt(r))) return !1; o = !0; } return o && t !== '_'; } } if (t === '_') return !1; for (;r < i; r++) if ((t = e[r]) !== '_') { if (!k(e.charCodeAt(r))) return !1; o = !0; } return !(!o || t === '_'); },
    construct(e) { let t; let n = e; let i = 1; if (n.indexOf('_') !== -1 && (n = n.replace(/_/g, '')), (t = n[0]) !== '-' && t !== '+' || (t === '-' && (i = -1), t = (n = n.slice(1))[0]), n === '0') return 0; if (t === '0') { if (n[1] === 'b') return i * parseInt(n.slice(2), 2); if (n[1] === 'x') return i * parseInt(n.slice(2), 16); if (n[1] === 'o') return i * parseInt(n.slice(2), 8); } return i * parseInt(n, 10); },
    predicate(e) { return Object.prototype.toString.call(e) === '[object Number]' && e % 1 == 0 && !n.isNegativeZero(e); },
    represent: {
      binary(e) { return e >= 0 ? `0b${e.toString(2)}` : `-0b${e.toString(2).slice(1)}`; }, octal(e) { return e >= 0 ? `0o${e.toString(8)}` : `-0o${e.toString(8).slice(1)}`; }, decimal(e) { return e.toString(10); }, hexadecimal(e) { return e >= 0 ? `0x${e.toString(16).toUpperCase()}` : `-0x${e.toString(16).toUpperCase().slice(1)}`; },
    },
    defaultStyle: 'decimal',
    styleAliases: {
      binary: [2, 'bin'], octal: [8, 'oct'], decimal: [10, 'dec'], hexadecimal: [16, 'hex'],
    },
  }); const x = new RegExp('^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$'); const I = /^[-+]?[0-9]+e/; const S = new p('tag:yaml.org,2002:float', {
    kind: 'scalar', resolve(e) { return e !== null && !(!x.test(e) || e[e.length - 1] === '_'); }, construct(e) { let t; let n; return n = (t = e.replace(/_/g, '').toLowerCase())[0] === '-' ? -1 : 1, '+-'.indexOf(t[0]) >= 0 && (t = t.slice(1)), t === '.inf' ? n === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : t === '.nan' ? NaN : n * parseFloat(t, 10); }, predicate(e) { return Object.prototype.toString.call(e) === '[object Number]' && (e % 1 != 0 || n.isNegativeZero(e)); }, represent(e, t) { let i; if (isNaN(e)) switch (t) { case 'lowercase': return '.nan'; case 'uppercase': return '.NAN'; case 'camelcase': return '.NaN'; } else if (Number.POSITIVE_INFINITY === e) switch (t) { case 'lowercase': return '.inf'; case 'uppercase': return '.INF'; case 'camelcase': return '.Inf'; } else if (Number.NEGATIVE_INFINITY === e) switch (t) { case 'lowercase': return '-.inf'; case 'uppercase': return '-.INF'; case 'camelcase': return '-.Inf'; } else if (n.isNegativeZero(e)) return '-0.0'; return i = e.toString(10), I.test(i) ? i.replace('e', '.e') : i; }, defaultStyle: 'lowercase',
  }); const O = b.extend({ implicit: [A, v, C, S] }); const j = O; const T = new RegExp('^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$'); const N = new RegExp('^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$'); const F = new p('tag:yaml.org,2002:timestamp', {
    kind: 'scalar', resolve(e) { return e !== null && (T.exec(e) !== null || N.exec(e) !== null); }, construct(e) { let t; let n; let i; let r; let o; let a; let l; let c; let s = 0; let u = null; if ((t = T.exec(e)) === null && (t = N.exec(e)), t === null) throw new Error('Date resolve error'); if (n = +t[1], i = +t[2] - 1, r = +t[3], !t[4]) return new Date(Date.UTC(n, i, r)); if (o = +t[4], a = +t[5], l = +t[6], t[7]) { for (s = t[7].slice(0, 3); s.length < 3;)s += '0'; s = +s; } return t[9] && (u = 6e4 * (60 * +t[10] + +(t[11] || 0)), t[9] === '-' && (u = -u)), c = new Date(Date.UTC(n, i, r, o, a, l, s)), u && c.setTime(c.getTime() - u), c; }, instanceOf: Date, represent(e) { return e.toISOString(); },
  }); const E = new p('tag:yaml.org,2002:merge', { kind: 'scalar', resolve(e) { return e === '<<' || e === null; } }); const M = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r'; const L = new p('tag:yaml.org,2002:binary', {
    kind: 'scalar', resolve(e) { if (e === null) return !1; let t; let n; let i = 0; const r = e.length; const o = M; for (n = 0; n < r; n++) if (!((t = o.indexOf(e.charAt(n))) > 64)) { if (t < 0) return !1; i += 6; } return i % 8 == 0; }, construct(e) { let t; let n; const i = e.replace(/[\r\n=]/g, ''); const r = i.length; const o = M; let a = 0; const l = []; for (t = 0; t < r; t++)t % 4 == 0 && t && (l.push(a >> 16 & 255), l.push(a >> 8 & 255), l.push(255 & a)), a = a << 6 | o.indexOf(i.charAt(t)); return (n = r % 4 * 6) === 0 ? (l.push(a >> 16 & 255), l.push(a >> 8 & 255), l.push(255 & a)) : n === 18 ? (l.push(a >> 10 & 255), l.push(a >> 2 & 255)) : n === 12 && l.push(a >> 4 & 255), new Uint8Array(l); }, predicate(e) { return Object.prototype.toString.call(e) === '[object Uint8Array]'; }, represent(e) { let t; let n; let i = ''; let r = 0; const o = e.length; const a = M; for (t = 0; t < o; t++)t % 3 == 0 && t && (i += a[r >> 18 & 63], i += a[r >> 12 & 63], i += a[r >> 6 & 63], i += a[63 & r]), r = (r << 8) + e[t]; return (n = o % 3) === 0 ? (i += a[r >> 18 & 63], i += a[r >> 12 & 63], i += a[r >> 6 & 63], i += a[63 & r]) : n === 2 ? (i += a[r >> 10 & 63], i += a[r >> 4 & 63], i += a[r << 2 & 63], i += a[64]) : n === 1 && (i += a[r >> 2 & 63], i += a[r << 4 & 63], i += a[64], i += a[64]), i; },
  }); const _ = Object.prototype.hasOwnProperty; const D = Object.prototype.toString; const U = new p('tag:yaml.org,2002:omap', { kind: 'sequence', resolve(e) { if (e === null) return !0; let t; let n; let i; let r; let o; const a = []; const l = e; for (t = 0, n = l.length; t < n; t += 1) { if (i = l[t], o = !1, D.call(i) !== '[object Object]') return !1; for (r in i) if (_.call(i, r)) { if (o) return !1; o = !0; } if (!o) return !1; if (a.indexOf(r) !== -1) return !1; a.push(r); } return !0; }, construct(e) { return e !== null ? e : []; } }); const q = Object.prototype.toString; const Y = new p('tag:yaml.org,2002:pairs', { kind: 'sequence', resolve(e) { if (e === null) return !0; let t; let n; let i; let r; let o; const a = e; for (o = new Array(a.length), t = 0, n = a.length; t < n; t += 1) { if (i = a[t], q.call(i) !== '[object Object]') return !1; if ((r = Object.keys(i)).length !== 1) return !1; o[t] = [r[0], i[r[0]]]; } return !0; }, construct(e) { if (e === null) return []; let t; let n; let i; let r; let o; const a = e; for (o = new Array(a.length), t = 0, n = a.length; t < n; t += 1)i = a[t], r = Object.keys(i), o[t] = [r[0], i[r[0]]]; return o; } }); const R = Object.prototype.hasOwnProperty; const B = new p('tag:yaml.org,2002:set', { kind: 'mapping', resolve(e) { if (e === null) return !0; let t; const n = e; for (t in n) if (R.call(n, t) && n[t] !== null) return !1; return !0; }, construct(e) { return e !== null ? e : {}; } }); const K = j.extend({ implicit: [F, E], explicit: [L, U, Y, B] }); const P = Object.prototype.hasOwnProperty; const W = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/; const H = /[\x85\u2028\u2029]/; const $ = /[,\[\]\{\}]/; const G = /^(?:!|!!|![a-z\-]+!)$/i; const V = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i; function Z(e) { return Object.prototype.toString.call(e); } function J(e) { return e === 10 || e === 13; } function Q(e) { return e === 9 || e === 32; } function z(e) { return e === 9 || e === 32 || e === 10 || e === 13; } function X(e) { return e === 44 || e === 91 || e === 93 || e === 123 || e === 125; } function ee(e) { let t; return e >= 48 && e <= 57 ? e - 48 : (t = 32 | e) >= 97 && t <= 102 ? t - 97 + 10 : -1; } function te(e) { return e === 48 ? '\0' : e === 97 ? '' : e === 98 ? '\b' : e === 116 || e === 9 ? '\t' : e === 110 ? '\n' : e === 118 ? '\v' : e === 102 ? '\f' : e === 114 ? '\r' : e === 101 ? '' : e === 32 ? ' ' : e === 34 ? '"' : e === 47 ? '/' : e === 92 ? '\\' : e === 78 ? 'Â…' : e === 95 ? 'Â ' : e === 76 ? '\u2028' : e === 80 ? '\u2029' : ''; } function ne(e) { return e <= 65535 ? String.fromCharCode(e) : String.fromCharCode(55296 + (e - 65536 >> 10), 56320 + (e - 65536 & 1023)); } for (var ie = new Array(256), re = new Array(256), oe = 0; oe < 256; oe++)ie[oe] = te(oe) ? 1 : 0, re[oe] = te(oe); function ae(e, t) { this.input = e, this.filename = t.filename || null, this.schema = t.schema || K, this.onWarning = t.onWarning || null, this.legacy = t.legacy || !1, this.json = t.json || !1, this.listener = t.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = e.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.firstTabInLine = -1, this.documents = []; } function le(e, t) {
    const n = {
      name: e.filename, buffer: e.input.slice(0, -1), position: e.position, line: e.line, column: e.position - e.lineStart,
    }; return n.snippet = c(n), new o(t, n);
  } function ce(e, t) { throw le(e, t); } function se(e, t) { e.onWarning && e.onWarning.call(null, le(e, t)); } const ue = { YAML(e, t, n) { let i; let r; let o; e.version !== null && ce(e, 'duplication of %YAML directive'), n.length !== 1 && ce(e, 'YAML directive accepts exactly one argument'), (i = /^([0-9]+)\.([0-9]+)$/.exec(n[0])) === null && ce(e, 'ill-formed argument of the YAML directive'), r = parseInt(i[1], 10), o = parseInt(i[2], 10), r !== 1 && ce(e, 'unacceptable YAML version of the document'), e.version = n[0], e.checkLineBreaks = o < 2, o !== 1 && o !== 2 && se(e, 'unsupported YAML version of the document'); }, TAG(e, t, n) { let i; let r; n.length !== 2 && ce(e, 'TAG directive accepts exactly two arguments'), i = n[0], r = n[1], G.test(i) || ce(e, 'ill-formed tag handle (first argument) of the TAG directive'), P.call(e.tagMap, i) && ce(e, `there is a previously declared suffix for "${i}" tag handle`), V.test(r) || ce(e, 'ill-formed tag prefix (second argument) of the TAG directive'); try { r = decodeURIComponent(r); } catch (t) { ce(e, `tag prefix is malformed: ${r}`); }e.tagMap[i] = r; } }; function pe(e, t, n, i) { let r; let o; let a; let l; if (t < n) { if (l = e.input.slice(t, n), i) for (r = 0, o = l.length; r < o; r += 1)(a = l.charCodeAt(r)) === 9 || a >= 32 && a <= 1114111 || ce(e, 'expected valid JSON character'); else W.test(l) && ce(e, 'the stream contains non-printable characters'); e.result += l; } } function fe(e, t, i, r) { let o; let a; let l; let c; for (n.isObject(i) || ce(e, 'cannot merge mappings; the provided source object is unacceptable'), l = 0, c = (o = Object.keys(i)).length; l < c; l += 1)a = o[l], P.call(t, a) || (t[a] = i[a], r[a] = !0); } function de(e, t, n, i, r, o, a, l, c) {
    let s; let u; if (Array.isArray(r)) for (s = 0, u = (r = Array.prototype.slice.call(r)).length; s < u; s += 1)Array.isArray(r[s]) && ce(e, 'nested arrays are not supported inside keys'), typeof r === 'object' && Z(r[s]) === '[object Object]' && (r[s] = '[object Object]'); if (typeof r === 'object' && Z(r) === '[object Object]' && (r = '[object Object]'), r = String(r), t === null && (t = {}), i === 'tag:yaml.org,2002:merge') if (Array.isArray(o)) for (s = 0, u = o.length; s < u; s += 1)fe(e, t, o[s], n); else fe(e, t, o, n); else {
      e.json || P.call(n, r) || !P.call(t, r) || (e.line = a || e.line, e.lineStart = l || e.lineStart, e.position = c || e.position, ce(e, 'duplicated mapping key')), r === '__proto__' ? Object.defineProperty(t, r, {
        configurable: !0, enumerable: !0, writable: !0, value: o,
      }) : t[r] = o, delete n[r];
    } return t;
  } function he(e) { let t; (t = e.input.charCodeAt(e.position)) === 10 ? e.position++ : t === 13 ? (e.position++, e.input.charCodeAt(e.position) === 10 && e.position++) : ce(e, 'a line break is expected'), e.line += 1, e.lineStart = e.position, e.firstTabInLine = -1; } function ge(e, t, n) { for (var i = 0, r = e.input.charCodeAt(e.position); r !== 0;) { for (;Q(r);)r === 9 && e.firstTabInLine === -1 && (e.firstTabInLine = e.position), r = e.input.charCodeAt(++e.position); if (t && r === 35) do { r = e.input.charCodeAt(++e.position); } while (r !== 10 && r !== 13 && r !== 0);if (!J(r)) break; for (he(e), r = e.input.charCodeAt(e.position), i++, e.lineIndent = 0; r === 32;)e.lineIndent++, r = e.input.charCodeAt(++e.position); } return n !== -1 && i !== 0 && e.lineIndent < n && se(e, 'deficient indentation'), i; } function me(e) { let t; let n = e.position; return !((t = e.input.charCodeAt(n)) !== 45 && t !== 46 || t !== e.input.charCodeAt(n + 1) || t !== e.input.charCodeAt(n + 2) || (n += 3, (t = e.input.charCodeAt(n)) !== 0 && !z(t))); } function ye(e, t) { t === 1 ? e.result += ' ' : t > 1 && (e.result += n.repeat('\n', t - 1)); } function be(e, t) { let n; let i; const r = e.tag; const o = e.anchor; const a = []; let l = !1; if (e.firstTabInLine !== -1) return !1; for (e.anchor !== null && (e.anchorMap[e.anchor] = a), i = e.input.charCodeAt(e.position); i !== 0 && (e.firstTabInLine !== -1 && (e.position = e.firstTabInLine, ce(e, 'tab characters must not be used in indentation')), i === 45) && z(e.input.charCodeAt(e.position + 1));) if (l = !0, e.position++, ge(e, !0, -1) && e.lineIndent <= t)a.push(null), i = e.input.charCodeAt(e.position); else if (n = e.line, we(e, t, 3, !1, !0), a.push(e.result), ge(e, !0, -1), i = e.input.charCodeAt(e.position), (e.line === n || e.lineIndent > t) && i !== 0)ce(e, 'bad indentation of a sequence entry'); else if (e.lineIndent < t) break; return !!l && (e.tag = r, e.anchor = o, e.kind = 'sequence', e.result = a, !0); } function Ae(e) { let t; let n; let i; let r; let o = !1; let a = !1; if ((r = e.input.charCodeAt(e.position)) !== 33) return !1; if (e.tag !== null && ce(e, 'duplication of a tag property'), (r = e.input.charCodeAt(++e.position)) === 60 ? (o = !0, r = e.input.charCodeAt(++e.position)) : r === 33 ? (a = !0, n = '!!', r = e.input.charCodeAt(++e.position)) : n = '!', t = e.position, o) { do { r = e.input.charCodeAt(++e.position); } while (r !== 0 && r !== 62);e.position < e.length ? (i = e.input.slice(t, e.position), r = e.input.charCodeAt(++e.position)) : ce(e, 'unexpected end of the stream within a verbatim tag'); } else { for (;r !== 0 && !z(r);)r === 33 && (a ? ce(e, 'tag suffix cannot contain exclamation marks') : (n = e.input.slice(t - 1, e.position + 1), G.test(n) || ce(e, 'named tag handle cannot contain such characters'), a = !0, t = e.position + 1)), r = e.input.charCodeAt(++e.position); i = e.input.slice(t, e.position), $.test(i) && ce(e, 'tag suffix cannot contain flow indicator characters'); }i && !V.test(i) && ce(e, `tag name cannot contain such characters: ${i}`); try { i = decodeURIComponent(i); } catch (t) { ce(e, `tag name is malformed: ${i}`); } return o ? e.tag = i : P.call(e.tagMap, n) ? e.tag = e.tagMap[n] + i : n === '!' ? e.tag = `!${i}` : n === '!!' ? e.tag = `tag:yaml.org,2002:${i}` : ce(e, `undeclared tag handle "${n}"`), !0; } function ve(e) { let t; let n; if ((n = e.input.charCodeAt(e.position)) !== 38) return !1; for (e.anchor !== null && ce(e, 'duplication of an anchor property'), n = e.input.charCodeAt(++e.position), t = e.position; n !== 0 && !z(n) && !X(n);)n = e.input.charCodeAt(++e.position); return e.position === t && ce(e, 'name of an anchor node must contain at least one character'), e.anchor = e.input.slice(t, e.position), !0; } function we(e, t, i, r, o) { let a; let l; let c; let s; let u; let p; let f; let d; let h; let g = 1; let m = !1; let y = !1; if (e.listener !== null && e.listener('open', e), e.tag = null, e.anchor = null, e.kind = null, e.result = null, a = l = c = i === 4 || i === 3, r && ge(e, !0, -1) && (m = !0, e.lineIndent > t ? g = 1 : e.lineIndent === t ? g = 0 : e.lineIndent < t && (g = -1)), g === 1) for (;Ae(e) || ve(e);)ge(e, !0, -1) ? (m = !0, c = a, e.lineIndent > t ? g = 1 : e.lineIndent === t ? g = 0 : e.lineIndent < t && (g = -1)) : c = !1; if (c && (c = m || o), g !== 1 && i !== 4 || (d = i === 1 || i === 2 ? t : t + 1, h = e.position - e.lineStart, g === 1 ? c && (be(e, h) || (function (e, t, n) { let i; let r; let o; let a; let l; let c; let s; const u = e.tag; const p = e.anchor; const f = {}; const d = Object.create(null); let h = null; let g = null; let m = null; let y = !1; let b = !1; if (e.firstTabInLine !== -1) return !1; for (e.anchor !== null && (e.anchorMap[e.anchor] = f), s = e.input.charCodeAt(e.position); s !== 0;) { if (y || e.firstTabInLine === -1 || (e.position = e.firstTabInLine, ce(e, 'tab characters must not be used in indentation')), i = e.input.charCodeAt(e.position + 1), o = e.line, s !== 63 && s !== 58 || !z(i)) { if (a = e.line, l = e.lineStart, c = e.position, !we(e, n, 2, !1, !0)) break; if (e.line === o) { for (s = e.input.charCodeAt(e.position); Q(s);)s = e.input.charCodeAt(++e.position); if (s === 58)z(s = e.input.charCodeAt(++e.position)) || ce(e, 'a whitespace character is expected after the key-value separator within a block mapping'), y && (de(e, f, d, h, g, null, a, l, c), h = g = m = null), b = !0, y = !1, r = !1, h = e.tag, g = e.result; else { if (!b) return e.tag = u, e.anchor = p, !0; ce(e, 'can not read an implicit mapping pair; a colon is missed'); } } else { if (!b) return e.tag = u, e.anchor = p, !0; ce(e, 'can not read a block mapping entry; a multiline key may not be an implicit key'); } } else s === 63 ? (y && (de(e, f, d, h, g, null, a, l, c), h = g = m = null), b = !0, y = !0, r = !0) : y ? (y = !1, r = !0) : ce(e, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line'), e.position += 1, s = i; if ((e.line === o || e.lineIndent > t) && (y && (a = e.line, l = e.lineStart, c = e.position), we(e, t, 4, !0, r) && (y ? g = e.result : m = e.result), y || (de(e, f, d, h, g, m, a, l, c), h = g = m = null), ge(e, !0, -1), s = e.input.charCodeAt(e.position)), (e.line === o || e.lineIndent > t) && s !== 0)ce(e, 'bad indentation of a mapping entry'); else if (e.lineIndent < t) break; } return y && de(e, f, d, h, g, null, a, l, c), b && (e.tag = u, e.anchor = p, e.kind = 'mapping', e.result = f), b; }(e, h, d))) || (function (e, t) { let n; let i; let r; let o; let a; let l; let c; let s; let u; let p; let f; let d; let h = !0; const g = e.tag; const m = e.anchor; const y = Object.create(null); if ((d = e.input.charCodeAt(e.position)) === 91)a = 93, s = !1, o = []; else { if (d !== 123) return !1; a = 125, s = !0, o = {}; } for (e.anchor !== null && (e.anchorMap[e.anchor] = o), d = e.input.charCodeAt(++e.position); d !== 0;) { if (ge(e, !0, t), (d = e.input.charCodeAt(e.position)) === a) return e.position++, e.tag = g, e.anchor = m, e.kind = s ? 'mapping' : 'sequence', e.result = o, !0; h ? d === 44 && ce(e, "expected the node content, but found ','") : ce(e, 'missed comma between flow collection entries'), f = null, l = c = !1, d === 63 && z(e.input.charCodeAt(e.position + 1)) && (l = c = !0, e.position++, ge(e, !0, t)), n = e.line, i = e.lineStart, r = e.position, we(e, t, 1, !1, !0), p = e.tag, u = e.result, ge(e, !0, t), d = e.input.charCodeAt(e.position), !c && e.line !== n || d !== 58 || (l = !0, d = e.input.charCodeAt(++e.position), ge(e, !0, t), we(e, t, 1, !1, !0), f = e.result), s ? de(e, o, y, p, u, f, n, i, r) : l ? o.push(de(e, null, y, p, u, f, n, i, r)) : o.push(u), ge(e, !0, t), (d = e.input.charCodeAt(e.position)) === 44 ? (h = !0, d = e.input.charCodeAt(++e.position)) : h = !1; }ce(e, 'unexpected end of the stream within a flow collection'); }(e, d)) ? y = !0 : (l && (function (e, t) { let i; let r; let o; let a; let l; let c = 1; let s = !1; let u = !1; let p = t; let f = 0; let d = !1; if ((a = e.input.charCodeAt(e.position)) === 124)r = !1; else { if (a !== 62) return !1; r = !0; } for (e.kind = 'scalar', e.result = ''; a !== 0;) if ((a = e.input.charCodeAt(++e.position)) === 43 || a === 45)c === 1 ? c = a === 43 ? 3 : 2 : ce(e, 'repeat of a chomping mode identifier'); else { if (!((o = (l = a) >= 48 && l <= 57 ? l - 48 : -1) >= 0)) break; o === 0 ? ce(e, 'bad explicit indentation width of a block scalar; it cannot be less than one') : u ? ce(e, 'repeat of an indentation width identifier') : (p = t + o - 1, u = !0); } if (Q(a)) { do { a = e.input.charCodeAt(++e.position); } while (Q(a));if (a === 35) do { a = e.input.charCodeAt(++e.position); } while (!J(a) && a !== 0); } for (;a !== 0;) { for (he(e), e.lineIndent = 0, a = e.input.charCodeAt(e.position); (!u || e.lineIndent < p) && a === 32;)e.lineIndent++, a = e.input.charCodeAt(++e.position); if (!u && e.lineIndent > p && (p = e.lineIndent), J(a))f++; else { if (e.lineIndent < p) { c === 3 ? e.result += n.repeat('\n', s ? 1 + f : f) : c === 1 && s && (e.result += '\n'); break; } for (r ? Q(a) ? (d = !0, e.result += n.repeat('\n', s ? 1 + f : f)) : d ? (d = !1, e.result += n.repeat('\n', f + 1)) : f === 0 ? s && (e.result += ' ') : e.result += n.repeat('\n', f) : e.result += n.repeat('\n', s ? 1 + f : f), s = !0, u = !0, f = 0, i = e.position; !J(a) && a !== 0;)a = e.input.charCodeAt(++e.position); pe(e, i, e.position, !1); } } return !0; }(e, d)) || (function (e, t) { let n; let i; let r; if ((n = e.input.charCodeAt(e.position)) !== 39) return !1; for (e.kind = 'scalar', e.result = '', e.position++, i = r = e.position; (n = e.input.charCodeAt(e.position)) !== 0;) if (n === 39) { if (pe(e, i, e.position, !0), (n = e.input.charCodeAt(++e.position)) !== 39) return !0; i = e.position, e.position++, r = e.position; } else J(n) ? (pe(e, i, r, !0), ye(e, ge(e, !1, t)), i = r = e.position) : e.position === e.lineStart && me(e) ? ce(e, 'unexpected end of the document within a single quoted scalar') : (e.position++, r = e.position); ce(e, 'unexpected end of the stream within a single quoted scalar'); }(e, d)) || (function (e, t) { let n; let i; let r; let o; let a; let l; let c; if ((l = e.input.charCodeAt(e.position)) !== 34) return !1; for (e.kind = 'scalar', e.result = '', e.position++, n = i = e.position; (l = e.input.charCodeAt(e.position)) !== 0;) { if (l === 34) return pe(e, n, e.position, !0), e.position++, !0; if (l === 92) { if (pe(e, n, e.position, !0), J(l = e.input.charCodeAt(++e.position)))ge(e, !1, t); else if (l < 256 && ie[l])e.result += re[l], e.position++; else if ((a = (c = l) === 120 ? 2 : c === 117 ? 4 : c === 85 ? 8 : 0) > 0) { for (r = a, o = 0; r > 0; r--)(a = ee(l = e.input.charCodeAt(++e.position))) >= 0 ? o = (o << 4) + a : ce(e, 'expected hexadecimal character'); e.result += ne(o), e.position++; } else ce(e, 'unknown escape sequence'); n = i = e.position; } else J(l) ? (pe(e, n, i, !0), ye(e, ge(e, !1, t)), n = i = e.position) : e.position === e.lineStart && me(e) ? ce(e, 'unexpected end of the document within a double quoted scalar') : (e.position++, i = e.position); }ce(e, 'unexpected end of the stream within a double quoted scalar'); }(e, d)) ? y = !0 : !(function (e) { let t; let n; let i; if ((i = e.input.charCodeAt(e.position)) !== 42) return !1; for (i = e.input.charCodeAt(++e.position), t = e.position; i !== 0 && !z(i) && !X(i);)i = e.input.charCodeAt(++e.position); return e.position === t && ce(e, 'name of an alias node must contain at least one character'), n = e.input.slice(t, e.position), P.call(e.anchorMap, n) || ce(e, `unidentified alias "${n}"`), e.result = e.anchorMap[n], ge(e, !0, -1), !0; }(e)) ? (function (e, t, n) { let i; let r; let o; let a; let l; let c; let s; let u; const p = e.kind; const f = e.result; if (z(u = e.input.charCodeAt(e.position)) || X(u) || u === 35 || u === 38 || u === 42 || u === 33 || u === 124 || u === 62 || u === 39 || u === 34 || u === 37 || u === 64 || u === 96) return !1; if ((u === 63 || u === 45) && (z(i = e.input.charCodeAt(e.position + 1)) || n && X(i))) return !1; for (e.kind = 'scalar', e.result = '', r = o = e.position, a = !1; u !== 0;) { if (u === 58) { if (z(i = e.input.charCodeAt(e.position + 1)) || n && X(i)) break; } else if (u === 35) { if (z(e.input.charCodeAt(e.position - 1))) break; } else { if (e.position === e.lineStart && me(e) || n && X(u)) break; if (J(u)) { if (l = e.line, c = e.lineStart, s = e.lineIndent, ge(e, !1, -1), e.lineIndent >= t) { a = !0, u = e.input.charCodeAt(e.position); continue; }e.position = o, e.line = l, e.lineStart = c, e.lineIndent = s; break; } }a && (pe(e, r, o, !1), ye(e, e.line - l), r = o = e.position, a = !1), Q(u) || (o = e.position + 1), u = e.input.charCodeAt(++e.position); } return pe(e, r, o, !1), !!e.result || (e.kind = p, e.result = f, !1); }(e, d, i === 1)) && (y = !0, e.tag === null && (e.tag = '?')) : (y = !0, e.tag === null && e.anchor === null || ce(e, 'alias node should not have any properties')), e.anchor !== null && (e.anchorMap[e.anchor] = e.result)) : g === 0 && (y = c && be(e, h))), e.tag === null)e.anchor !== null && (e.anchorMap[e.anchor] = e.result); else if (e.tag === '?') { for (e.result !== null && e.kind !== 'scalar' && ce(e, `unacceptable node kind for !<?> tag; it should be "scalar", not "${e.kind}"`), s = 0, u = e.implicitTypes.length; s < u; s += 1) if ((f = e.implicitTypes[s]).resolve(e.result)) { e.result = f.construct(e.result), e.tag = f.tag, e.anchor !== null && (e.anchorMap[e.anchor] = e.result); break; } } else if (e.tag !== '!') { if (P.call(e.typeMap[e.kind || 'fallback'], e.tag))f = e.typeMap[e.kind || 'fallback'][e.tag]; else for (f = null, s = 0, u = (p = e.typeMap.multi[e.kind || 'fallback']).length; s < u; s += 1) if (e.tag.slice(0, p[s].tag.length) === p[s].tag) { f = p[s]; break; }f || ce(e, `unknown tag !<${e.tag}>`), e.result !== null && f.kind !== e.kind && ce(e, `unacceptable node kind for !<${e.tag}> tag; it should be "${f.kind}", not "${e.kind}"`), f.resolve(e.result, e.tag) ? (e.result = f.construct(e.result, e.tag), e.anchor !== null && (e.anchorMap[e.anchor] = e.result)) : ce(e, `cannot resolve a node with !<${e.tag}> explicit tag`); } return e.listener !== null && e.listener('close', e), e.tag !== null || e.anchor !== null || y; } function ke(e) { let t; let n; let i; let r; const o = e.position; let a = !1; for (e.version = null, e.checkLineBreaks = e.legacy, e.tagMap = Object.create(null), e.anchorMap = Object.create(null); (r = e.input.charCodeAt(e.position)) !== 0 && (ge(e, !0, -1), r = e.input.charCodeAt(e.position), !(e.lineIndent > 0 || r !== 37));) { for (a = !0, r = e.input.charCodeAt(++e.position), t = e.position; r !== 0 && !z(r);)r = e.input.charCodeAt(++e.position); for (i = [], (n = e.input.slice(t, e.position)).length < 1 && ce(e, 'directive name must not be less than one character in length'); r !== 0;) { for (;Q(r);)r = e.input.charCodeAt(++e.position); if (r === 35) { do { r = e.input.charCodeAt(++e.position); } while (r !== 0 && !J(r));break; } if (J(r)) break; for (t = e.position; r !== 0 && !z(r);)r = e.input.charCodeAt(++e.position); i.push(e.input.slice(t, e.position)); }r !== 0 && he(e), P.call(ue, n) ? ue[n](e, n, i) : se(e, `unknown document directive "${n}"`); }ge(e, !0, -1), e.lineIndent === 0 && e.input.charCodeAt(e.position) === 45 && e.input.charCodeAt(e.position + 1) === 45 && e.input.charCodeAt(e.position + 2) === 45 ? (e.position += 3, ge(e, !0, -1)) : a && ce(e, 'directives end mark is expected'), we(e, e.lineIndent - 1, 4, !1, !0), ge(e, !0, -1), e.checkLineBreaks && H.test(e.input.slice(o, e.position)) && se(e, 'non-ASCII line breaks are interpreted as content'), e.documents.push(e.result), e.position === e.lineStart && me(e) ? e.input.charCodeAt(e.position) === 46 && (e.position += 3, ge(e, !0, -1)) : e.position < e.length - 1 && ce(e, 'end of the stream or a document separator is expected'); } function Ce(e, t) { t = t || {}, (e = String(e)).length !== 0 && (e.charCodeAt(e.length - 1) !== 10 && e.charCodeAt(e.length - 1) !== 13 && (e += '\n'), e.charCodeAt(0) === 65279 && (e = e.slice(1))); const n = new ae(e, t); const i = e.indexOf('\0'); for (i !== -1 && (n.position = i, ce(n, 'null byte is not allowed in input')), n.input += '\0'; n.input.charCodeAt(n.position) === 32;)n.lineIndent += 1, n.position += 1; for (;n.position < n.length - 1;)ke(n); return n.documents; } const xe = { loadAll(e, t, n) { t !== null && typeof t === 'object' && void 0 === n && (n = t, t = null); const i = Ce(e, n); if (typeof t !== 'function') return i; for (let r = 0, o = i.length; r < o; r += 1)t(i[r]); }, load(e, t) { const n = Ce(e, t); if (n.length !== 0) { if (n.length === 1) return n[0]; throw new o('expected a single document in the stream, but found more'); } } }; const Ie = Object.prototype.toString; const Se = Object.prototype.hasOwnProperty; const Oe = 65279; const je = {
    0: '\\0', 7: '\\a', 8: '\\b', 9: '\\t', 10: '\\n', 11: '\\v', 12: '\\f', 13: '\\r', 27: '\\e', 34: '\\"', 92: '\\\\', 133: '\\N', 160: '\\_', 8232: '\\L', 8233: '\\P',
  }; const Te = ['y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON', 'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF']; const Ne = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/; function Fe(e) { let t; let i; let r; if (t = e.toString(16).toUpperCase(), e <= 255)i = 'x', r = 2; else if (e <= 65535)i = 'u', r = 4; else { if (!(e <= 4294967295)) throw new o('code point within a string may not be greater than 0xFFFFFFFF'); i = 'U', r = 8; } return `\\${i}${n.repeat('0', r - t.length)}${t}`; } function Ee(e) { this.schema = e.schema || K, this.indent = Math.max(1, e.indent || 2), this.noArrayIndent = e.noArrayIndent || !1, this.skipInvalid = e.skipInvalid || !1, this.flowLevel = n.isNothing(e.flowLevel) ? -1 : e.flowLevel, this.styleMap = (function (e, t) { let n; let i; let r; let o; let a; let l; let c; if (t === null) return {}; for (n = {}, r = 0, o = (i = Object.keys(t)).length; r < o; r += 1)a = i[r], l = String(t[a]), a.slice(0, 2) === '!!' && (a = `tag:yaml.org,2002:${a.slice(2)}`), (c = e.compiledTypeMap.fallback[a]) && Se.call(c.styleAliases, l) && (l = c.styleAliases[l]), n[a] = l; return n; }(this.schema, e.styles || null)), this.sortKeys = e.sortKeys || !1, this.lineWidth = e.lineWidth || 80, this.noRefs = e.noRefs || !1, this.noCompatMode = e.noCompatMode || !1, this.condenseFlow = e.condenseFlow || !1, this.quotingType = e.quotingType === '"' ? 2 : 1, this.forceQuotes = e.forceQuotes || !1, this.replacer = typeof e.replacer === 'function' ? e.replacer : null, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = '', this.duplicates = [], this.usedDuplicates = null; } function Me(e, t) { for (var i, r = n.repeat(' ', t), o = 0, a = -1, l = '', c = e.length; o < c;)(a = e.indexOf('\n', o)) === -1 ? (i = e.slice(o), o = c) : (i = e.slice(o, a + 1), o = a + 1), i.length && i !== '\n' && (l += r), l += i; return l; } function Le(e, t) { return `\n${n.repeat(' ', e.indent * t)}`; } function _e(e) { return e === 32 || e === 9; } function De(e) { return e >= 32 && e <= 126 || e >= 161 && e <= 55295 && e !== 8232 && e !== 8233 || e >= 57344 && e <= 65533 && e !== Oe || e >= 65536 && e <= 1114111; } function Ue(e) { return De(e) && e !== Oe && e !== 13 && e !== 10; } function qe(e, t, n) { const i = Ue(e); const r = i && !_e(e); return (n ? i : i && e !== 44 && e !== 91 && e !== 93 && e !== 123 && e !== 125) && e !== 35 && !(t === 58 && !r) || Ue(t) && !_e(t) && e === 35 || t === 58 && r; } function Ye(e, t) { let n; const i = e.charCodeAt(t); return i >= 55296 && i <= 56319 && t + 1 < e.length && (n = e.charCodeAt(t + 1)) >= 56320 && n <= 57343 ? 1024 * (i - 55296) + n - 56320 + 65536 : i; } function Re(e) { return /^\n* /.test(e); } function Be(e, t, n, i, r, o, a, l) { let c; let s; let u = 0; let p = null; let f = !1; let d = !1; const h = i !== -1; let g = -1; let m = De(s = Ye(e, 0)) && s !== Oe && !_e(s) && s !== 45 && s !== 63 && s !== 58 && s !== 44 && s !== 91 && s !== 93 && s !== 123 && s !== 125 && s !== 35 && s !== 38 && s !== 42 && s !== 33 && s !== 124 && s !== 61 && s !== 62 && s !== 39 && s !== 34 && s !== 37 && s !== 64 && s !== 96 && (function (e) { return !_e(e) && e !== 58; }(Ye(e, e.length - 1))); if (t || a) for (c = 0; c < e.length; u >= 65536 ? c += 2 : c++) { if (!De(u = Ye(e, c))) return 5; m = m && qe(u, p, l), p = u; } else { for (c = 0; c < e.length; u >= 65536 ? c += 2 : c++) { if ((u = Ye(e, c)) === 10)f = !0, h && (d = d || c - g - 1 > i && e[g + 1] !== ' ', g = c); else if (!De(u)) return 5; m = m && qe(u, p, l), p = u; }d = d || h && c - g - 1 > i && e[g + 1] !== ' '; } return f || d ? n > 9 && Re(e) ? 5 : a ? o === 2 ? 5 : 2 : d ? 4 : 3 : !m || a || r(e) ? o === 2 ? 5 : 2 : 1; } function Ke(e, t, n, i, r) { e.dump = (function () { if (t.length === 0) return e.quotingType === 2 ? '""' : "''"; if (!e.noCompatMode && (Te.indexOf(t) !== -1 || Ne.test(t))) return e.quotingType === 2 ? `"${t}"` : `'${t}'`; const a = e.indent * Math.max(1, n); const l = e.lineWidth === -1 ? -1 : Math.max(Math.min(e.lineWidth, 40), e.lineWidth - a); const c = i || e.flowLevel > -1 && n >= e.flowLevel; switch (Be(t, c, e.indent, l, ((t) => (function (e, t) { let n; let i; for (n = 0, i = e.implicitTypes.length; n < i; n += 1) if (e.implicitTypes[n].resolve(t)) return !0; return !1; }(e, t))), e.quotingType, e.forceQuotes && !i, r)) { case 1: return t; case 2: return `'${t.replace(/'/g, "''")}'`; case 3: return `|${Pe(t, e.indent)}${We(Me(t, a))}`; case 4: return `>${Pe(t, e.indent)}${We(Me((function (e, t) { let n; let i; const r = /(\n+)([^\n]*)/g; let o = (l = e.indexOf('\n'), l = l !== -1 ? l : e.length, r.lastIndex = l, He(e.slice(0, l), t)); let a = e[0] === '\n' || e[0] === ' '; let l; for (;i = r.exec(e);) { const c = i[1]; const s = i[2]; n = s[0] === ' ', o += c + (a || n || s === '' ? '' : '\n') + He(s, t), a = n; } return o; }(t, l)), a))}`; case 5: return `"${(function (e) { for (var t, n = '', i = 0, r = 0; r < e.length; i >= 65536 ? r += 2 : r++)i = Ye(e, r), !(t = je[i]) && De(i) ? (n += e[r], i >= 65536 && (n += e[r + 1])) : n += t || Fe(i); return n; }(t))}"`; default: throw new o('impossible error: invalid scalar style'); } }()); } function Pe(e, t) {
    const n = Re(e) ? String(t) : ''; const
      i = e[e.length - 1] === '\n'; return `${n + (i && (e[e.length - 2] === '\n' || e === '\n') ? '+' : i ? '' : '-')}\n`;
  } function We(e) { return e[e.length - 1] === '\n' ? e.slice(0, -1) : e; } function He(e, t) { if (e === '' || e[0] === ' ') return e; for (var n, i, r = / [^ ]/g, o = 0, a = 0, l = 0, c = ''; n = r.exec(e);)(l = n.index) - o > t && (i = a > o ? a : l, c += `\n${e.slice(o, i)}`, o = i + 1), a = l; return c += '\n', e.length - o > t && a > o ? c += `${e.slice(o, a)}\n${e.slice(a + 1)}` : c += e.slice(o), c.slice(1); } function $e(e, t, n, i) { let r; let o; let a; let l = ''; const c = e.tag; for (r = 0, o = n.length; r < o; r += 1)a = n[r], e.replacer && (a = e.replacer.call(n, String(r), a)), (Ve(e, t + 1, a, !0, !0, !1, !0) || void 0 === a && Ve(e, t + 1, null, !0, !0, !1, !0)) && (i && l === '' || (l += Le(e, t)), e.dump && e.dump.charCodeAt(0) === 10 ? l += '-' : l += '- ', l += e.dump); e.tag = c, e.dump = l || '[]'; } function Ge(e, t, n) { let i; let r; let a; let l; let c; let s; for (a = 0, l = (r = n ? e.explicitTypes : e.implicitTypes).length; a < l; a += 1) if (((c = r[a]).instanceOf || c.predicate) && (!c.instanceOf || typeof t === 'object' && t instanceof c.instanceOf) && (!c.predicate || c.predicate(t))) { if (n ? c.multi && c.representName ? e.tag = c.representName(t) : e.tag = c.tag : e.tag = '?', c.represent) { if (s = e.styleMap[c.tag] || c.defaultStyle, Ie.call(c.represent) === '[object Function]')i = c.represent(t, s); else { if (!Se.call(c.represent, s)) throw new o(`!<${c.tag}> tag resolver accepts not "${s}" style`); i = c.represent[s](t, s); }e.dump = i; } return !0; } return !1; } function Ve(e, t, n, i, r, a, l) { e.tag = null, e.dump = n, Ge(e, n, !1) || Ge(e, n, !0); let c; const s = Ie.call(e.dump); const u = i; i && (i = e.flowLevel < 0 || e.flowLevel > t); let p; let f; const d = s === '[object Object]' || s === '[object Array]'; if (d && (f = (p = e.duplicates.indexOf(n)) !== -1), (e.tag !== null && e.tag !== '?' || f || e.indent !== 2 && t > 0) && (r = !1), f && e.usedDuplicates[p])e.dump = `*ref_${p}`; else { if (d && f && !e.usedDuplicates[p] && (e.usedDuplicates[p] = !0), s === '[object Object]')i && Object.keys(e.dump).length !== 0 ? (!(function (e, t, n, i) { let r; let a; let l; let c; let s; let u; let p = ''; const f = e.tag; const d = Object.keys(n); if (!0 === e.sortKeys)d.sort(); else if (typeof e.sortKeys === 'function')d.sort(e.sortKeys); else if (e.sortKeys) throw new o('sortKeys must be a boolean or a function'); for (r = 0, a = d.length; r < a; r += 1)u = '', i && p === '' || (u += Le(e, t)), c = n[l = d[r]], e.replacer && (c = e.replacer.call(n, l, c)), Ve(e, t + 1, l, !0, !0, !0) && ((s = e.tag !== null && e.tag !== '?' || e.dump && e.dump.length > 1024) && (e.dump && e.dump.charCodeAt(0) === 10 ? u += '?' : u += '? '), u += e.dump, s && (u += Le(e, t)), Ve(e, t + 1, c, !0, s) && (e.dump && e.dump.charCodeAt(0) === 10 ? u += ':' : u += ': ', p += u += e.dump)); e.tag = f, e.dump = p || '{}'; }(e, t, e.dump, r)), f && (e.dump = `&ref_${p}${e.dump}`)) : (!(function (e, t, n) { let i; let r; let o; let a; let l; let c = ''; const s = e.tag; const u = Object.keys(n); for (i = 0, r = u.length; i < r; i += 1)l = '', c !== '' && (l += ', '), e.condenseFlow && (l += '"'), a = n[o = u[i]], e.replacer && (a = e.replacer.call(n, o, a)), Ve(e, t, o, !1, !1) && (e.dump.length > 1024 && (l += '? '), l += `${e.dump + (e.condenseFlow ? '"' : '')}:${e.condenseFlow ? '' : ' '}`, Ve(e, t, a, !1, !1) && (c += l += e.dump)); e.tag = s, e.dump = `{${c}}`; }(e, t, e.dump)), f && (e.dump = `&ref_${p} ${e.dump}`)); else if (s === '[object Array]')i && e.dump.length !== 0 ? (e.noArrayIndent && !l && t > 0 ? $e(e, t - 1, e.dump, r) : $e(e, t, e.dump, r), f && (e.dump = `&ref_${p}${e.dump}`)) : (!(function (e, t, n) { let i; let r; let o; let a = ''; const l = e.tag; for (i = 0, r = n.length; i < r; i += 1)o = n[i], e.replacer && (o = e.replacer.call(n, String(i), o)), (Ve(e, t, o, !1, !1) || void 0 === o && Ve(e, t, null, !1, !1)) && (a !== '' && (a += `,${e.condenseFlow ? '' : ' '}`), a += e.dump); e.tag = l, e.dump = `[${a}]`; }(e, t, e.dump)), f && (e.dump = `&ref_${p} ${e.dump}`)); else { if (s !== '[object String]') { if (s === '[object Undefined]') return !1; if (e.skipInvalid) return !1; throw new o(`unacceptable kind of an object to dump ${s}`); }e.tag !== '?' && Ke(e, e.dump, t, a, u); }e.tag !== null && e.tag !== '?' && (c = encodeURI(e.tag[0] === '!' ? e.tag.slice(1) : e.tag).replace(/!/g, '%21'), c = e.tag[0] === '!' ? `!${c}` : c.slice(0, 18) === 'tag:yaml.org,2002:' ? `!!${c.slice(18)}` : `!<${c}>`, e.dump = `${c} ${e.dump}`); } return !0; } function Ze(e, t) { let n; let i; const r = []; const o = []; for (Je(e, r, o), n = 0, i = o.length; n < i; n += 1)t.duplicates.push(r[o[n]]); t.usedDuplicates = new Array(i); } function Je(e, t, n) { let i; let r; let o; if (e !== null && typeof e === 'object') if ((r = t.indexOf(e)) !== -1)n.indexOf(r) === -1 && n.push(r); else if (t.push(e), Array.isArray(e)) for (r = 0, o = e.length; r < o; r += 1)Je(e[r], t, n); else for (r = 0, o = (i = Object.keys(e)).length; r < o; r += 1)Je(e[i[r]], t, n); } function Qe(e, t) { return function () { throw new Error(`Function yaml.${e} is removed in js-yaml 4. Use yaml.${t} instead, which is now safe by default.`); }; } const ze = p; const Xe = h; const et = b; const tt = O; const nt = j; const it = K; const rt = xe.load; const ot = xe.loadAll; const at = { dump(e, t) { const n = new Ee(t = t || {}); n.noRefs || Ze(e, n); let i = e; return n.replacer && (i = n.replacer.call({ '': i }, '', i)), Ve(n, 0, i, !0, !0) ? `${n.dump}\n` : ''; } }.dump; const lt = o; const ct = {
    binary: L, float: S, map: y, null: A, pairs: Y, set: B, timestamp: F, bool: v, int: C, merge: E, omap: U, seq: m, str: g,
  }; const st = Qe('safeLoad', 'load'); const ut = Qe('safeLoadAll', 'loadAll'); const pt = Qe('safeDump', 'dump'); const ft = {
    Type: ze, Schema: Xe, FAILSAFE_SCHEMA: et, JSON_SCHEMA: tt, CORE_SCHEMA: nt, DEFAULT_SCHEMA: it, load: rt, loadAll: ot, dump: at, YAMLException: lt, types: ct, safeLoad: st, safeLoadAll: ut, safeDump: pt,
  }; e.CORE_SCHEMA = nt, e.DEFAULT_SCHEMA = it, e.FAILSAFE_SCHEMA = et, e.JSON_SCHEMA = tt, e.Schema = Xe, e.Type = ze, e.YAMLException = lt, e.default = ft, e.dump = at, e.load = rt, e.loadAll = ot, e.safeDump = pt, e.safeLoad = st, e.safeLoadAll = ut, e.types = ct, Object.defineProperty(e, '__esModule', { value: !0 });
})));
